{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A Pymoo plugin for <code>ropt</code>","text":"<p>The <code>ropt-pymoo</code> package extends the <code>ropt</code> module by providing a plugin that integrates optimization algorithms from the <code>pymoo</code> toolkit.  <code>ropt</code> itself is a robust optimization framework designed for both continuous and discrete optimization workflows and is extensible through its plugin architecture. Installing <code>ropt-pymoo</code> makes these <code>pymoo</code> algorithms directly available within <code>ropt</code>.</p>"},{"location":"example/","title":"Example","text":"<p>Here is an example of a simple constrained discrete problem, solved using a genetic algorithm:</p> <pre><code>from pathlib import Path\nimport numpy as np\nfrom ropt.evaluator import EvaluatorResult\nfrom ropt.plan import BasicOptimizer\nfrom ruamel import yaml\n\n# For convenience we use a YAML file to store the optimizer options:\noptions = yaml.YAML(typ=\"safe\", pure=True).load(Path(\"options.yml\"))\n\nCONFIG = {\n    \"variables\": {\n        # Ignored, but needed to establish the number of variables:\n        \"initial_values\": 2 * [0.0],\n        \"lower_bounds\": [0.0, 0.0],\n        \"upper_bounds\": [10.0, 10.0],\n    },\n    \"optimizer\": {\n        \"method\": \"soo.nonconvex.ga.GA\",\n        \"options\": options,\n    },\n    \"nonlinear_constraints\": {\"lower_bounds\": [-np.inf], \"upper_bounds\": [0.0]},\n}\n\ndef function(variables, _):\n    x, y = variables[0, :]\n    objectives = np.array(-min(3 * x, y), ndmin=2, dtype=np.float64)\n    constraints = np.array(x + y - 10, ndmin=2, dtype=np.float64)\n    return EvaluatorResult(objectives=objectives, constraints=constraints)\n\noptimal_result = BasicOptimizer(CONFIG, function).run().results\nprint(f\"Optimal variables: {optimal_result.evaluations.variables}\")\nprint(f\"Optimal objective: {optimal_result.functions.weighted_objective}\")\n</code></pre> <p>To run, first create a YAML file called <code>options.yml</code> with the following contents:</p> <pre><code>parameters:\n  pop_size: 20\n  sampling:\n    object: operators.sampling.rnd.IntegerRandomSampling\n  crossover:\n    object: operators.crossover.sbx.SBX\n    parameters:\n      prob: 1.0\n      eta: 3.0\n      vtype: float\n      repair:\n        object: operators.repair.rounding.RoundingRepair\n  mutation:\n    object: operators.mutation.pm.PM\n    parameters:\n      prob: 1.0\n      eta: 3.0\n      vtype: float\n      repair:\n        object: operators.repair.rounding.RoundingRepair\n  eliminate_duplicates: True\n\ntermination:\n  name: max_gen.MaximumGenerationTermination\n  parameters:\n    n_max_gen: 10\n\nconstraints:\n  name: as_penalty.ConstraintsAsPenalty\n  parameters:\n    penalty: 100.0\n\nseed: 1234\n</code></pre> <p>Running this will output the following: <pre><code>$ python example.py\n=================================================\nn_gen  |  n_eval  |     f_avg     |     f_min    \n=================================================\n     1 |       18 |  1.740556E+02 | -6.000000E+00\n     2 |       38 | -2.300000E+00 | -6.000000E+00\n     3 |       58 | -3.600000E+00 | -6.000000E+00\n     4 |       78 | -4.400000E+00 | -7.000000E+00\n     5 |       98 | -4.450000E+00 | -7.000000E+00\n     6 |      118 | -4.500000E+00 | -7.000000E+00\n     7 |      138 | -4.600000E+00 | -7.000000E+00\n     8 |      158 | -4.600000E+00 | -7.000000E+00\n     9 |      178 | -4.600000E+00 | -7.000000E+00\n    10 |      198 | -4.600000E+00 | -7.000000E+00\nOptimal variables: [3. 7.]\nOptimal objective: -7.0\n</code></pre></p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#ropt_pymoo.pymoo.PyMooOptimizer","title":"ropt_pymoo.pymoo.PyMooOptimizer","text":"<p>               Bases: <code>Optimizer</code></p> <p>Pymoo optimization backend for ropt.</p> <p>This class provides an interface to several optimization algorithms from <code>pymoo</code>, enabling their use within <code>ropt</code>.</p> <p>To select an optimizer, set the <code>method</code> field within the <code>optimizer</code> section of the <code>EnOptConfig</code> configuration object to the desired algorithm's name. The name should be a fully qualified class name within the <code>pymoo.algorithms</code> module (e.g., <code>soo.nonconvex.ga.GA</code>).</p> <p>For algorithm-specific options, use the <code>options</code> dictionary within the <code>optimizer</code> section, which will be parsed into a <code>ParametersConfig</code> object.</p>"},{"location":"reference/#ropt_pymoo.config.ParametersConfig","title":"ropt_pymoo.config.ParametersConfig","text":"<p>Configuration of a <code>pymoo</code> algorithm.</p> <p>The general structure of the configuration is as follows:</p> <ul> <li> <p>Algorithm Parameters: Arguments passed directly to the main     algorithm's constructor are nested under a top-level <code>parameters</code> key.</p> </li> <li> <p>Object Parameters: When a parameter's value is itself a <code>pymoo</code>     object, specify it using a nested dictionary, which will be parsed into     a <code>ObjectConfig</code> object, containing:</p> <ul> <li>An <code>object</code> key: The fully qualified name of the <code>pymoo</code> class     (e.g., <code>\"operators.sampling.rnd.IntegerRandomSampling\"</code>).</li> <li>An optional <code>parameters</code> key: A dictionary of arguments to pass to     that object's constructor. This can be nested further if those     arguments are also objects.</li> </ul> </li> <li> <p>Termination, Constraints, Seed: These are typically defined using     their own top-level keys (<code>termination</code>, <code>constraints</code>, <code>seed</code>) within     the <code>options</code> dictionary, following the same <code>object</code>/<code>parameters</code>     pattern if they require configuration:</p> <ul> <li>A <code>termination</code> field is parsed into a     <code>TerminationConfig</code> object if     it is dictionary, or passed to the     <code>pymoo.termination.get_termination()</code>     function if it is a tuple of arguments.</li> <li>A <code>constraints</code> field is parsed into a     <code>ConstraintsConfig</code> object.</li> <li>A <code>seed</code> field is parsed into an integer value.</li> </ul> </li> </ul> Note <p><code>constraints</code>, <code>termination</code>, and <code>seed</code> are optional:</p> <ul> <li>If <code>constraints</code> is <code>None</code>, the default constraint handling of      <code>pymoo</code> will apply.</li> <li>If <code>termination</code> is <code>None</code>, the default termination criterion <code>soo</code>      is used.</li> <li>The default value of <code>seed</code> is <code>1</code>.</li> </ul> <p>Attributes:</p> Name Type Description <code>parameters</code> <code>dict[str, ParameterValues | ObjectConfig]</code> <p>The parameters passed to the algorithm constructor</p> <code>constraints</code> <code>ConstraintsConfig | None</code> <p>Specification of the constraint handling object to use</p> <code>termination</code> <code>TerminationConfig | tuple[Any, ...]</code> <p>Specification of the termination object to use</p> <code>seed</code> <code>int</code> <p>The seed value for the random number generator</p>"},{"location":"reference/#ropt_pymoo.config.ObjectConfig","title":"ropt_pymoo.config.ObjectConfig","text":"<p>Configuration for a <code>pymoo</code> object used as a parameter.</p> <p>This class defines the configuration for <code>pymoo</code> objects (like operators, sampling methods, etc.) that are passed as parameters to other <code>pymoo</code> components (e.g., an algorithm).</p> <p>The object itself is identified by its fully qualified class name within the <code>pymoo</code> package structure. For instance, the <code>FloatRandomSampling</code> operator is specified as <code>'operators.sampling.rnd.FloatRandomSampling'</code>.</p> <p>Parameters for the object's constructor are provided in a dictionary. Values can be basic types (booleans, integers, floats, strings) or another nested <code>ObjectConfig</code> instance for complex parameter types.</p> <p>Attributes:</p> Name Type Description <code>object</code> <p>The fully qualified class name of the <code>pymoo</code> object.</p> <code>parameters</code> <code>dict[str, ParameterValues | ObjectConfig]</code> <p>A dictionary of keyword arguments.</p>"},{"location":"reference/#ropt_pymoo.config.TerminationConfig","title":"ropt_pymoo.config.TerminationConfig","text":"<p>Configuration for <code>pymoo</code> termination classes.</p> <p>This class defines how the termination object for a <code>pymoo</code> optimization algorithm is specified.</p> <p>The <code>name</code> attribute identifies the termination criterion by providing the full path to the termination class within the <code>pymoo.termination</code> module (e.g., <code>max_gen.MaximumGenerationTermination</code>).</p> <p>The <code>parameters</code> attribute holds a dictionary of keyword arguments that will be passed to the constructor of the chosen termination criterion.</p> <p>For details about termination objects, consult the <code>pymoo</code> manual: Termination Criterion.</p> Note <p>Instead of using a termination object, it is also possible to use a tuple of termination conditions. See the <code>ParametersConfig</code> class for details.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The fully qualified termination class name.</p> <code>parameters</code> <code>dict[str, int | float]</code> <p>Keyword arguments for the termination criterion's constructor.</p>"},{"location":"reference/#ropt_pymoo.config.ConstraintsConfig","title":"ropt_pymoo.config.ConstraintsConfig","text":"<p>Configuration for <code>pymoo</code> constraint handling methods.</p> <p>This class defines how constraint handling is configured for a <code>pymoo</code> optimization.</p> <p>The <code>name</code> attribute specifies the constraint handling class using its fully qualified name within the <code>pymoo.constraints</code> module (e.g., <code>as_penalty.ConstraintsAsPenalty</code>).</p> <p>The <code>parameters</code> attribute holds a dictionary of keyword arguments passed to the constructor of the chosen constraint handling class.</p> <p>For more details on constraint handling, consult the <code>pymoo</code> manual: <code>Constraint Handling</code>.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The fully qualified name of the constraint handling class.</p> <code>parameters</code> <code>dict[str, bool | int | float | str]</code> <p>Keyword arguments for the constraint handling class constructor.</p>"},{"location":"reference/#ropt_pymoo.config.ParameterValues","title":"ParameterValues  <code>module-attribute</code>","text":"<pre><code>ParameterValues = bool | int | float | str\n</code></pre> <p>Types of values that can be passed as parameters to pymoo objects.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#introduction","title":"Introduction","text":"<p>An optimization by ropt using the plugin works mostly as any other optimization run. However, there are a few things to consider:</p> <ol> <li>Gradient Information: The plugin does not use gradient information, as     <code>pymoo</code> algorithms typically don't support user-defined gradients. Any     gradient calculation settings in <code>ropt</code> will be ignored.</li> <li>Ignored <code>ropt</code> Parameters: Some standard <code>ropt</code> optimization parameters     like <code>max_iterations</code> and <code>tolerance</code> are not used by this plugin and will     have no effect.</li> <li>Initial Values: <code>pymoo</code> generally ignores initial variable values.     However, you still need to provide an initial value vector in <code>ropt</code> simply     to define the number of variables; a zero vector is sufficient for this     purpose.</li> <li>Constraint Support: Both linear and non-linear constraints are handled.     Linear constraints are automatically converted to non-linear constraints     internally before being passed to <code>pymoo</code>.</li> <li>Algorithm Specification: You must specify the <code>pymoo</code> algorithm using     its fully qualified object name as found in the <code>pymoo.algorithms</code> module     (e.g., <code>soo.nonconvex.ga.GA</code>), not just a short name.</li> <li>Algorithm Configuration via <code>options</code>: The chosen <code>pymoo</code> algorithm and     its specific parameters are configured entirely through the <code>options</code> field     within the <code>ropt</code> configuration object. The structure of this <code>options</code>     dictionary directly mirrors the way options are set in <code>pymoo</code>, as detailed     in the configuration section below.</li> </ol>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>The algorithm to specify is set by the <code>method</code> field in <code>optimization</code> section of a <code>ropt</code> configuration. Futher configuration of <code>pymoo</code> algorithms is performed via the <code>options</code> field. The following example demonstrates the configuration process for a Genetic Algorithm, derived from the <code>pymoo</code> manual, incorporating a penalty constraint. Here is how this is done in <code>pymoo</code>:</p> <pre><code>from pymoo.algorithms.soo.nonconvex.ga import GA\nfrom pymoo.operators.crossover.sbx import SBX\nfrom pymoo.operators.mutation.pm import PM\nfrom pymoo.operators.repair.rounding import RoundingRepair\nfrom pymoo.operators.sampling.rnd import IntegerRandomSampling\nfrom pymoo.optimize import minimize\nfrom pymoo.constraints.as_penalty import ConstraintsAsPenalty\nfrom pymoo.problems import get_problem\n\nproblem = get_problem(\"g1\")\n\nmethod = GA(\n    pop_size=20,\n    sampling=IntegerRandomSampling(),\n    crossover=SBX(prob=1.0, eta=3.0, vtype=float, repair=RoundingRepair()),\n    mutation=PM(prob=1.0, eta=3.0, vtype=float, repair=RoundingRepair()),\n    eliminate_duplicates=True,\n)\n\nres = minimize(\n    ConstraintsAsPenalty(problem, penalty=100.0),\n    method,\n    termination=(\"n_gen\", 40),\n    seed=1234,\n)\n</code></pre> <p>To configure the equivalent optimization in <code>ropt</code>, first set the <code>method</code> field within the <code>optimization</code> section of the <code>ropt</code> configuration to the fully qualified name of the algorithm object in the <code>pymoo.algorithms</code> module (e.g., <code>\"soo.nonconvex.ga.GA\"</code>).</p> <p>Next, define the specific algorithm parameters, termination criteria, constraints handling object, and random seed within the <code>options</code> field. This field accepts a nested dictionary structure. The <code>ropt-pymoo</code> plugin parses this dictionary to instantiate and configure the necessary <code>pymoo</code> objects based on the provided names and parameters.</p> <p>The general structure within the <code>options</code> dictionary is as follows:</p> <ul> <li>Algorithm Parameters: Arguments passed directly to the main algorithm's   constructor (like <code>pop_size</code> for <code>GA</code>) are typically nested under a   top-level <code>parameters</code> key.</li> <li>Object Parameters: When a parameter's value is itself a <code>pymoo</code> object   (e.g., <code>sampling</code>, <code>crossover</code>, <code>mutation</code>), specify it using a nested   dictionary containing:<ul> <li>An <code>object</code> key: The fully qualified name of the <code>pymoo</code> class (e.g.,   <code>\"operators.sampling.rnd.IntegerRandomSampling\"</code>).</li> <li>An optional <code>parameters</code> key: A dictionary of arguments to pass to   that object's constructor. This can be nested further if those   arguments are also objects.</li> </ul> </li> <li>Termination, Constraints, Seed: These are typically defined using their   own top-level keys (<code>termination</code>, <code>constraints</code>, <code>seed</code>) within the   <code>options</code> dictionary, often following the same <code>object</code>/<code>parameters</code> pattern   if they require configuration.</li> </ul> <p>For clarity, the configuration corresponding to the preceding Python <code>GA</code> example is shown below in YAML format, demonstrating how simple values and nested objects are specified.</p> <p>Within the <code>options</code> dictionary, the <code>parameters</code> key holds the arguments for the <code>GA</code> object. The keys inside this <code>parameters</code> dictionary correspond to the keyword arguments accepted by the <code>GA</code> constructor:</p> <pre><code>parameters:\n  pop_size: 20\n  sampling:  # Specify objects using their fully qualified names:\n    object: operators.sampling.rnd.IntegerRandomSampling\n  crossover:\n    object: operators.crossover.sbx.SBX\n    parameters:  # Specify parameters to an object with a `parameters` field:\n      prob: 1.0\n      eta: 3.0\n      vtype: float\n      repair:\n        object: operators.repair.rounding.RoundingRepair\n  mutation:\n    object: operators.mutation.pm.PM\n    parameters:\n      prob: 1.0\n      eta: 3.0\n      vtype: float\n      repair:\n        object: operators.repair.rounding.RoundingRepair\n  eliminate_duplicates: True\n</code></pre> <p>The termination criterion is configured using the <code>termination</code> field, either by using a list of parameters that is passed on to the <code>pymoo.termination.get_termination()</code> function:</p> <pre><code>termination: [\"n_iter\", 30]\n</code></pre> <p>Alternatively, the termination can be configured using a specific termination object. Specify this object using its fully qualified name from the <code>pymoo.termination</code> module:</p> <pre><code>termination:\n  name: max_gen.MaximumGenerationTermination\n  parameters:\n    n_max_gen: 10\n</code></pre> <p>Constraints defined in the <code>ropt</code> configuration are automatically passed to <code>pymoo</code> for handling. You can customize how <code>pymoo</code> manages these constraints by specifying a particular constraint handling class, such as <code>ConstraintsAsPenalty</code> used in the example. To configure this, add a <code>constraints</code> field to the <code>options</code> dictionary, specifying the fully qualified name of the desired class from the <code>pymoo.constraints</code> module and its parameters:</p> <pre><code>constraints:\n  name: as_penalty.ConstraintsAsPenalty\n  parameters:\n    penalty: 100.0\n</code></pre> <p>Finally, since <code>GA</code> requires random number generation, we specify a seed:</p> <pre><code>seed: 1234\n</code></pre>"}]}